// Generated by dts-bundle v0.2.0

declare module 'ts-events' {
    import syncEvent = require("__ts-events/lib/sync-event");
    export import SyncEvent = syncEvent.SyncEvent;
    export import VoidSyncEvent = syncEvent.VoidSyncEvent;
    export import ErrorSyncEvent = syncEvent.ErrorSyncEvent;
    import queuedEvent = require("__ts-events/lib/queued-event");
    export import QueuedEvent = queuedEvent.QueuedEvent;
    export import VoidQueuedEvent = queuedEvent.VoidQueuedEvent;
    export import ErrorQueuedEvent = queuedEvent.ErrorQueuedEvent;
    import asyncEvent = require("__ts-events/lib/async-event");
    export import AsyncEvent = asyncEvent.AsyncEvent;
    export import VoidAsyncEvent = asyncEvent.VoidAsyncEvent;
    export import ErrorAsyncEvent = asyncEvent.ErrorAsyncEvent;
    export import EventQueue = require("__ts-events/lib/EventQueue");
    import anyEvent = require("__ts-events/lib/any-event");
    export import AnyEvent = anyEvent.AnyEvent;
    export import VoidAnyEvent = anyEvent.VoidAnyEvent;
    export import ErrorAnyEvent = anyEvent.ErrorAnyEvent;
    /**
        * The global event queue for QueuedEvents
        */
    export function queue(): EventQueue;
    /**
        * Convenience function, same as EventQueue.global().flushOnce().
        * Flushes the QueuedEvents, calling all events currently in the queue but not
        * any events put into the queue as a result of the flush.
        */
    export function flushOnce(): void;
    /**
        * Convenience function, same as EventQueue.global().flush().
        * Flushes the QueuedEvents, calling all handlers currently in the queue and those
        * put into the queue as a result of the flush.
        * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
        *                  the queue keeps filling up. Set to undefined or null to disable this.
        */
    export function flush(maxRounds?: number): void;
}

declare module '__ts-events/lib/sync-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    import Postable = baseEvent.Postable;
    /**
        * This is a true EventEmitter replacement: the handlers are called synchronously when
        * you post the event.
        * - Allows better error handling by aggregating any errors thrown by handlers.
        * - Prevents livelock by throwing an error when recursion depth is above a maximum.
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class SyncEvent<T> extends BaseEvent<T> implements Postable<T> {
            /**
                * Maximum number of times that an event handler may cause the same event
                * recursively.
                */
            static MAX_RECURSION_DEPTH: number;
            /**
                * Send the event. Handlers are called immediately and synchronously.
                * If an error is thrown by a handler, the remaining handlers are still called.
                * Afterward, an AggregateError is thrown with the original error(s) in its 'causes' property.
                */
            post(data: T): void;
    }
    /**
        * Convenience class for events without data
        */
    export class VoidSyncEvent extends SyncEvent<void> {
            /**
                * Send the event.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorSyncEvent extends SyncEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/queued-event' {
    import EventQueue = require("__ts-events/lib/EventQueue");
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    import Postable = baseEvent.Postable;
    /**
        * Options for the QueuedEvent constructor
        */
    export interface QueuedEventOpts {
            /**
                * Condense multiple calls to post() into one.
                */
            condensed?: boolean;
            /**
                * Specific event queue to use. If not provided, the global instance is used.
                */
            queue?: EventQueue;
    }
    /**
        * Event that stays in a queue until you process the queue. Allows fine-grained
        * control over when events happen.
        * - Optionally condenses multiple post() calls into one.
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class QueuedEvent<T> extends BaseEvent<T> implements Postable<T> {
            /**
                * Used internally - the exact options object given to constructor
                */
            options: QueuedEventOpts;
            /**
                * Constructor
                * @param opts Optional, an object with the following members:
                *             - condensed: a Boolean indicating whether to condense multiple calls to post() into one (default false)
                *             - queue: a specific event queue to use. The global EventQueue instance is used if not given.
                */
            constructor(opts?: QueuedEventOpts);
            /**
             * Send the event. Events are queued in the event queue until flushed out.
             * If the 'condensed' option was given in the constructor, multiple posts()
             * between queue flushes are condensed into one call with the data from the
             * last post() call.
             */
            post(data: T): void;
    }
    /**
        * Convenience class for events without data
        */
    export class VoidQueuedEvent extends QueuedEvent<void> {
            /**
                * Send the event.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorQueuedEvent extends QueuedEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/async-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import BaseEvent = baseEvent.BaseEvent;
    import Listener = baseEvent.Listener;
    import Postable = baseEvent.Postable;
    /**
        * Options for the AsyncEvent constructor
        */
    export interface AsyncEventOpts {
            /**
                * Condense multiple calls to post() into one while the previous one
                * has not been handled yet.
                */
            condensed?: boolean;
    }
    /**
        * A-synchronous event. Handlers are called in the next Node.JS cycle.
        * - Optionally condenses multiple post() calls into one (the last post() gets through)
        * - Handlers are called only for events posted after they were attached.
        * - Handlers are not called anymore when they are detached, even if a post() is in progress
        */
    export class AsyncEvent<T> extends BaseEvent<T> implements Postable<T> {
            /**
                * Used internally - the exact options object given to constructor
                */
            options: AsyncEventOpts;
            /**
                * The default scheduler uses setImmediate() or setTimeout(..., 0) if setImmediate is not available.
                */
            static defaultScheduler(callback: () => void): void;
            /**
                * By default, AsyncEvent uses setImmediate() to schedule event handler invocation.
                * You can change this for e.g. setTimeout(..., 0) by calling this static method once.
                * @param scheduler A function that takes a callback and executes it in the next Node.JS cycle.
                */
            static setScheduler(scheduler: (callback: () => void) => void): void;
            /**
                * Constructor
                * @param opts Optional. Various settings:
                *             - condensed: a Boolean indicating whether to condense multiple post() calls within the same cycle.
                */
            constructor(opts?: AsyncEventOpts);
            /**
                * Send the AsyncEvent. Handlers are called in the next Node.JS cycle.
                */
            post(data: T): void;
            protected _call(listener: Listener<T>, args: any[]): void;
            /**
                * Performance optimization: if this async signal is attached to another
                * async signal, we're already a the next cycle and we can call listeners
                * directly
                */
            protected _postDirect(args: any[]): void;
    }
    /**
        * Convenience class for AsyncEvents without data
        */
    export class VoidAsyncEvent extends AsyncEvent<void> {
            /**
                * Send the AsyncEvent.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorAsyncEvent extends AsyncEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/EventQueue' {
    import syncEvent = require("__ts-events/lib/sync-event");
    import SyncEvent = syncEvent.SyncEvent;
    /**
        * Simple synchronous event queue that needs to be drained manually.
        */
    class EventQueue {
            /**
                * SyncEvent triggered after an event is added outside of a flush operation.
                * @param queue The event queue itself
                */
            evtFilled: SyncEvent<EventQueue>;
            /**
                * SyncEvent triggered after the queue is flushed empty
                * @param queue The event queue itself
                */
            evtDrained: SyncEvent<EventQueue>;
            /**
                * The module-global event queue
                */
            static global(): EventQueue;
            /**
                * Testing purposes
                */
            static resetGlobal(): void;
            /**
                * Returns true iff the queue is empty
                */
            empty(): boolean;
            /**
                * Add an element to the queue. The handler is called when one of the flush
                * methods is called.
                */
            add(handler: () => void): void;
            /**
                * Calls all handlers currently in the queue. Does not call any handlers added
                * as a result of the flush
                */
            flushOnce(): void;
            /**
                * Flushes the QueuedEvents, calling all events currently in the queue and those
                * put into the queue as a result of the flush.
                * @param maxRounds Optional, default 10. Number of iterations after which to throw an error because
                *                  the queue keeps filling up. Set to null to disable this.
                */
            flush(maxRounds?: number): void;
    }
    export = EventQueue;
}

declare module '__ts-events/lib/any-event' {
    import baseEvent = require("__ts-events/lib/base-event");
    import Postable = baseEvent.Postable;
    import asyncEvent = require("__ts-events/lib/async-event");
    import AsyncEventOpts = asyncEvent.AsyncEventOpts;
    import queuedEvent = require("__ts-events/lib/queued-event");
    import QueuedEventOpts = queuedEvent.QueuedEventOpts;
    export enum EventType {
            Sync = 0,
            Async = 1,
            Queued = 2,
    }
    /**
        * An event that behaves like a Sync/Async/Queued event depending on how
        * you subscribe.
        */
    export class AnyEvent<T> implements Postable<T> {
            attachSync(handler: (data: T) => void): void;
            attachSync(boundTo: Object, handler: (data: T) => void): void;
            attachSync(event: Postable<T>): void;
            attachAsync(handler: (data: T) => void, opts?: AsyncEventOpts): void;
            attachAsync(boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts): void;
            attachAsync(event: Postable<T>, opts?: AsyncEventOpts): void;
            attachQueued(handler: (data: T) => void, opts?: QueuedEventOpts): void;
            attachQueued(boundTo: Object, handler: (data: T) => void, opts?: QueuedEventOpts): void;
            attachQueued(event: Postable<T>, opts?: QueuedEventOpts): void;
            detach(handler: (data: T) => void): void;
            detach(boundTo: Object, handler: (data: T) => void): void;
            detach(boundTo: Object): void;
            detach(event: Postable<T>): void;
            detach(): void;
            /**
                * Post an event to all current listeners
                */
            post(data: T): void;
            /**
                * The number of attached listeners
                */
            listenerCount(): number;
    }
    /**
        * Convenience class for AnyEvents without data
        */
    export class VoidAnyEvent extends AnyEvent<void> {
            /**
                * Send the AsyncEvent.
                */
            post(): void;
    }
    /**
        * Similar to "error" event on EventEmitter: throws when a post() occurs while no handlers set.
        */
    export class ErrorAnyEvent extends AnyEvent<Error> {
            post(data: Error): void;
    }
}

declare module '__ts-events/lib/base-event' {
    export interface Postable<T> {
            post(data: T): void;
    }
    /**
        * Internal interface between BaseEvent and its subclasses
        */
    export interface Listener<T> {
            /**
                * Indicates that the listener was detached
                */
            deleted: boolean;
            /**
                * The handler
                */
            handler?: (data: T) => void;
            /**
                * The this pointer for the handler
                */
            boundTo?: Object;
            /**
                * Instead of a handler, an attached event
                */
            event?: Postable<T>;
    }
    /**
        * Base class for events.
        * Handles attaching and detaching listeners
        */
    export class BaseEvent<T> implements Postable<T> {
            /**
                * Attached listeners. NOTE: do not modify.
                * Instead, replace with a new array with possibly the same elements. This ensures
                * that any references to the array by events that are underway remain the same.
                */
            protected _listeners: Listener<T>[];
            /**
                * Attach an event handler
                * @param handler The function to call. The this argument of the function will be this object.
                */
            attach(handler: (data: T) => void): void;
            /**
                * Attach an event handler
                * @param boundTo The this argument of the handler
                * @param handler The function to call.
                */
            attach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Attach an event directly
                * @param event The event to be posted
                */
            attach(event: Postable<T>): void;
            /**
                * Detach all listeners with the given handler function
                */
            detach(handler: (data: T) => void): void;
            /**
                * Detach all listeners with the given handler function and boundTo object.
                */
            detach(boundTo: Object, handler: (data: T) => void): void;
            /**
                * Detach all listeners that were attached with the given boundTo object.
                */
            detach(boundTo: Object): void;
            /**
                * Detach the given event.
                */
            detach(event: Postable<T>): void;
            /**
                * Detach all listeners
                */
            detach(): void;
            /**
                * Abstract post() method to be able to connect any type of event to any other directly
                * @abstract
                */
            post(data: T): void;
            /**
                * The number of attached listeners
                */
            listenerCount(): number;
            /**
                * Call the given listener, if it is not marked as 'deleted'
                * @param listener The listener to call
                * @param args The arguments to the handler
                */
            protected _call(listener: Listener<T>, args: any[]): void;
    }
}

